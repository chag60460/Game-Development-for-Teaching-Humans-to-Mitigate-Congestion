using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

public class TestingIDM : MonoBehaviour
{
    public GameObject[] wayPoints; //array of points

    int currentPoint = 0; // integer to keep track of which point we are on

    public float speed = 25.0f;

    public float rotationSpeed = 10.0f;

    //IDM Variables
    public float Acceleration = 2.0f;

    float desiredTime = 1f;
    float maxAcceleration = 2f;
    float brakeDecceleration = 1.5f;
    float delta = 4;
    float minimumSpacing = 1;
    float maxVelocity = 25;

    //IDM Model
    static float ComputeGap(GameObject trafficControlCar, GameObject leadCar)// Compute the gap between ego vehicle and lead vehicle
    {
        return leadCar.transform.position.z - trafficControlCar.transform.position.z;
    }

    void Next_Step(float dt)
    {
        // # Setting velocity of the vehicle according to the Euler numerical integration scheme.
        float v = Acceleration * dt;
        speed += v;

        //We make sure that vehicles do not have negative velocities (they do not move backwards)?
        if (speed < 0)
        {
            speed = 0;
        }

        //this.transform.Translate(Vector3.forward * speed * Time.deltaTime);

        //Debug.Log("v" + v);
        //Debug.Log("Velocity" + speed);

    }

    void IDM_Model(GameObject trafficControlcar, float dt, GameObject leadCar)
    {
        //This is the net distance between the two vehicles(self and vehicle_lead)
        float currentGap = ComputeGap(trafficControlcar, leadCar);

        if (trafficControlcar.name == "Traffic Control Car (24)")
        {
            currentGap = (float)5;
        }

        // IDM model
        float v_f = maxVelocity;

        float S = (float)(minimumSpacing + Math.Max(0, speed * desiredTime + speed * (speed - speed) / (2 * Math.Sqrt(maxAcceleration * brakeDecceleration))));
        //S = s_min + max(0, self.velocity.x * T + ((self.velocity.x * (self.velocity.x - self.velocity.x)) / (2 * math.sqrt(a_max * b))))
        //S is the same

        // Setting the vehicle's new acceleration here by setting 'self.acceleration' parameter
        Acceleration = (float)(maxAcceleration * (1 - Math.Pow((speed / v_f), delta) - Math.Pow((S / currentGap), 2)));
        //self.acceleration.xy = a_max * (1 - ((self.velocity.x / v_f) ** delta) - ((S / current_gap.x) ** 2)), 0

        //Debugging


        //S
        //Debug.Log("S" + S); 
        //Debug.Log("minimumSpacing" + minimumSpacing);
        //Debug.Log("speed" + speed);
        //Debug.Log("desiredTime" + desiredTime);
        //Debug.Log(speed * (speed - speed) / (2 * Math.Sqrt(maxAcceleration * brakeDecceleration)));
        //Debug.Log("speed * desiredTime" + speed * desiredTime);
        //Debug.Log(minimumSpacing + Math.Max(0, speed * desiredTime + speed * (speed - speed) / (2 * Math.Sqrt(maxAcceleration * brakeDecceleration))));
        //Debug.Log((float)minimumSpacing + Math.Max(0, speed * desiredTime + speed * (speed - speed) / (2 * Math.Sqrt(maxAcceleration * brakeDecceleration))));

        //Acceleration
        //Debug.Log("maxAcceleration" + maxAcceleration);
        //Debug.Log("delta" + delta);
        //Debug.Log("Math.Pow((speed / v_f), delta)" + Math.Pow((speed / v_f), delta));
        //Debug.Log("Math.Pow((S / currentGap), 2)" + Math.Pow((S / currentGap), 2));
        //Debug.Log("Acceleration" + Acceleration);


        Debug.Log("Car " + trafficControlcar.name);
        Debug.Log("current_lead_gap between " + trafficControlcar.name + " and " + leadCar.name + "is " + currentGap);
        Debug.Log("Acceleration " + Acceleration);
        Debug.Log(trafficControlcar.transform.position);

        Next_Step(dt);

        Debug.Log("Speed " + speed);
        Debug.Log("desiredTime" + desiredTime);

    }

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        //check to see what where we are in relation to the next wayPoint
        if (Vector3.Distance(this.transform.position, wayPoints[currentPoint].transform.position) < 3)
            currentPoint++;

        //if we've checked the distance for all the way points, set currentPoint to 0
        if (currentPoint >= wayPoints.Length)
            currentPoint = 0;

        //this.transform.LookAt(wayPoints[currentPoint].transform);
        Quaternion lookAtWayPoint = Quaternion.LookRotation(wayPoints[currentPoint].transform.position - this.transform.position);
        this.transform.rotation = Quaternion.Slerp(transform.rotation, lookAtWayPoint, rotationSpeed * Time.deltaTime);

        //Calling IDM
        IDM_Model(GameObject.Find("Traffic Control Car (20)"), (float)0.1, GameObject.Find("Traffic Control Car (21)"));

        IDM_Model(GameObject.Find("Traffic Control Car (21)"), (float)0.1, GameObject.Find("Traffic Control Car (22)"));
        IDM_Model(GameObject.Find("Traffic Control Car (22)"), (float)0.1, GameObject.Find("Traffic Control Car (23)"));
        IDM_Model(GameObject.Find("Traffic Control Car (23)"), (float)0.1, GameObject.Find("Traffic Control Car (24)"));
        //IDM_Model(GameObject.Find("Traffic Control Car (24)"), (float)0.1, GameObject.Find("Traffic Control Car (20)"));
        this.transform.Translate(0, 0, speed * Time.deltaTime);

    }
}
